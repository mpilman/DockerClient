//
// TaskSpecContainerSpec.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Container spec for the service.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are &gt; mutually exclusive. PluginSpec is only used when the Runtime field &gt; is set to &#x60;plugin&#x60;. NetworkAttachmentSpec is used when the Runtime &gt; field is set to &#x60;attachment&#x60;.  */
public struct TaskSpecContainerSpec: Codable, JSONEncodable, Hashable {

    public enum Isolation: String, Codable, CaseIterable {
        case _default = "default"
        case process = "process"
        case hyperv = "hyperv"
    }
    /** The image name to use for the container */
    public var image: String?
    /** User-defined key/value data. */
    public var labels: [String: String]?
    /** The command to be run in the image. */
    public var command: [String]?
    /** Arguments to the command. */
    public var args: [String]?
    /** The hostname to use for the container, as a valid [RFC 1123](https://tools.ietf.org/html/rfc1123) hostname.  */
    public var hostname: String?
    /** A list of environment variables in the form `VAR=value`.  */
    public var env: [String]?
    /** The working directory for commands to run in. */
    public var dir: String?
    /** The user inside the container. */
    public var user: String?
    /** A list of additional groups that the container process will run as.  */
    public var groups: [String]?
    public var privileges: TaskSpecContainerSpecPrivileges?
    /** Whether a pseudo-TTY should be allocated. */
    public var TTY: Bool?
    /** Open `stdin` */
    public var openStdin: Bool?
    /** Mount the container's root filesystem as read only. */
    public var readOnly: Bool?
    /** Specification for mounts to be added to containers created as part of the service.  */
    public var mounts: [Mount]?
    /** Signal to stop the container. */
    public var stopSignal: String?
    /** Amount of time to wait for the container to terminate before forcefully killing it.  */
    public var stopGracePeriod: Int64?
    public var healthCheck: HealthConfig?
    /** A list of hostname/IP mappings to add to the container's `hosts` file. The format of extra hosts is specified in the [hosts(5)](http://man7.org/linux/man-pages/man5/hosts.5.html) man page:      IP_address canonical_hostname [aliases...]  */
    public var hosts: [String]?
    public var dNSConfig: TaskSpecContainerSpecDNSConfig?
    /** Secrets contains references to zero or more secrets that will be exposed to the service.  */
    public var secrets: [TaskSpecContainerSpecSecretsInner]?
    /** Configs contains references to zero or more configs that will be exposed to the service.  */
    public var configs: [TaskSpecContainerSpecConfigsInner]?
    /** Isolation technology of the containers running the service. (Windows only)  */
    public var isolation: Isolation?
    /** Run an init inside the container that forwards signals and reaps processes. This field is omitted if empty, and the default (as configured on the daemon) is used.  */
    public var _init: Bool?
    /** Set kernel namedspaced parameters (sysctls) in the container. The Sysctls option on services accepts the same sysctls as the are supported on containers. Note that while the same sysctls are supported, no guarantees or checks are made about their suitability for a clustered environment, and it's up to the user to determine whether a given sysctl will work properly in a Service.  */
    public var sysctls: [String: String]?
    /** A list of kernel capabilities to add to the default set for the container.  */
    public var capabilityAdd: [String]?
    /** A list of kernel capabilities to drop from the default set for the container.  */
    public var capabilityDrop: [String]?
    /** A list of resource limits to set in the container. For example: `{\"Name\": \"nofile\", \"Soft\": 1024, \"Hard\": 2048}`\"  */
    public var ulimits: [ResourcesUlimitsInner]?

    public init(image: String? = nil, labels: [String: String]? = nil, command: [String]? = nil, args: [String]? = nil, hostname: String? = nil, env: [String]? = nil, dir: String? = nil, user: String? = nil, groups: [String]? = nil, privileges: TaskSpecContainerSpecPrivileges? = nil, TTY: Bool? = nil, openStdin: Bool? = nil, readOnly: Bool? = nil, mounts: [Mount]? = nil, stopSignal: String? = nil, stopGracePeriod: Int64? = nil, healthCheck: HealthConfig? = nil, hosts: [String]? = nil, dNSConfig: TaskSpecContainerSpecDNSConfig? = nil, secrets: [TaskSpecContainerSpecSecretsInner]? = nil, configs: [TaskSpecContainerSpecConfigsInner]? = nil, isolation: Isolation? = nil, _init: Bool? = nil, sysctls: [String: String]? = nil, capabilityAdd: [String]? = nil, capabilityDrop: [String]? = nil, ulimits: [ResourcesUlimitsInner]? = nil) {
        self.image = image
        self.labels = labels
        self.command = command
        self.args = args
        self.hostname = hostname
        self.env = env
        self.dir = dir
        self.user = user
        self.groups = groups
        self.privileges = privileges
        self.TTY = TTY
        self.openStdin = openStdin
        self.readOnly = readOnly
        self.mounts = mounts
        self.stopSignal = stopSignal
        self.stopGracePeriod = stopGracePeriod
        self.healthCheck = healthCheck
        self.hosts = hosts
        self.dNSConfig = dNSConfig
        self.secrets = secrets
        self.configs = configs
        self.isolation = isolation
        self._init = _init
        self.sysctls = sysctls
        self.capabilityAdd = capabilityAdd
        self.capabilityDrop = capabilityDrop
        self.ulimits = ulimits
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case image = "Image"
        case labels = "Labels"
        case command = "Command"
        case args = "Args"
        case hostname = "Hostname"
        case env = "Env"
        case dir = "Dir"
        case user = "User"
        case groups = "Groups"
        case privileges = "Privileges"
        case TTY
        case openStdin = "OpenStdin"
        case readOnly = "ReadOnly"
        case mounts = "Mounts"
        case stopSignal = "StopSignal"
        case stopGracePeriod = "StopGracePeriod"
        case healthCheck = "HealthCheck"
        case hosts = "Hosts"
        case dNSConfig = "DNSConfig"
        case secrets = "Secrets"
        case configs = "Configs"
        case isolation = "Isolation"
        case _init = "Init"
        case sysctls = "Sysctls"
        case capabilityAdd = "CapabilityAdd"
        case capabilityDrop = "CapabilityDrop"
        case ulimits = "Ulimits"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(image, forKey: .image)
        try container.encodeIfPresent(labels, forKey: .labels)
        try container.encodeIfPresent(command, forKey: .command)
        try container.encodeIfPresent(args, forKey: .args)
        try container.encodeIfPresent(hostname, forKey: .hostname)
        try container.encodeIfPresent(env, forKey: .env)
        try container.encodeIfPresent(dir, forKey: .dir)
        try container.encodeIfPresent(user, forKey: .user)
        try container.encodeIfPresent(groups, forKey: .groups)
        try container.encodeIfPresent(privileges, forKey: .privileges)
        try container.encodeIfPresent(TTY, forKey: .TTY)
        try container.encodeIfPresent(openStdin, forKey: .openStdin)
        try container.encodeIfPresent(readOnly, forKey: .readOnly)
        try container.encodeIfPresent(mounts, forKey: .mounts)
        try container.encodeIfPresent(stopSignal, forKey: .stopSignal)
        try container.encodeIfPresent(stopGracePeriod, forKey: .stopGracePeriod)
        try container.encodeIfPresent(healthCheck, forKey: .healthCheck)
        try container.encodeIfPresent(hosts, forKey: .hosts)
        try container.encodeIfPresent(dNSConfig, forKey: .dNSConfig)
        try container.encodeIfPresent(secrets, forKey: .secrets)
        try container.encodeIfPresent(configs, forKey: .configs)
        try container.encodeIfPresent(isolation, forKey: .isolation)
        try container.encodeIfPresent(_init, forKey: ._init)
        try container.encodeIfPresent(sysctls, forKey: .sysctls)
        try container.encodeIfPresent(capabilityAdd, forKey: .capabilityAdd)
        try container.encodeIfPresent(capabilityDrop, forKey: .capabilityDrop)
        try container.encodeIfPresent(ulimits, forKey: .ulimits)
    }
}

