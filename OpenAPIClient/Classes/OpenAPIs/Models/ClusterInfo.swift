//
// ClusterInfo.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** ClusterInfo represents information about the swarm as is returned by the \&quot;/info\&quot; endpoint. Join-tokens are not included.  */
public struct ClusterInfo: Codable, JSONEncodable, Hashable {

    static let subnetSizeRule = NumericRule<Int>(minimum: nil, exclusiveMinimum: false, maximum: 29, exclusiveMaximum: false, multipleOf: nil)
    /** The ID of the swarm. */
    public var ID: String?
    public var version: ObjectVersion?
    /** Date and time at which the swarm was initialised in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.  */
    public var createdAt: String?
    /** Date and time at which the swarm was last updated in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.  */
    public var updatedAt: String?
    public var spec: SwarmSpec?
    public var tLSInfo: TLSInfo?
    /** Whether there is currently a root CA rotation in progress for the swarm  */
    public var rootRotationInProgress: Bool?
    /** DataPathPort specifies the data path port number for data traffic. Acceptable port range is 1024 to 49151. If no port is set or is set to 0, the default port (4789) is used.  */
    public var dataPathPort: Int?
    /** Default Address Pool specifies default subnet pools for global scope networks.  */
    public var defaultAddrPool: [String]?
    /** SubnetSize specifies the subnet size of the networks created from the default subnet pool.  */
    public var subnetSize: Int?

    public init(ID: String? = nil, version: ObjectVersion? = nil, createdAt: String? = nil, updatedAt: String? = nil, spec: SwarmSpec? = nil, tLSInfo: TLSInfo? = nil, rootRotationInProgress: Bool? = nil, dataPathPort: Int? = nil, defaultAddrPool: [String]? = nil, subnetSize: Int? = nil) {
        self.ID = ID
        self.version = version
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.spec = spec
        self.tLSInfo = tLSInfo
        self.rootRotationInProgress = rootRotationInProgress
        self.dataPathPort = dataPathPort
        self.defaultAddrPool = defaultAddrPool
        self.subnetSize = subnetSize
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case ID
        case version = "Version"
        case createdAt = "CreatedAt"
        case updatedAt = "UpdatedAt"
        case spec = "Spec"
        case tLSInfo = "TLSInfo"
        case rootRotationInProgress = "RootRotationInProgress"
        case dataPathPort = "DataPathPort"
        case defaultAddrPool = "DefaultAddrPool"
        case subnetSize = "SubnetSize"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(ID, forKey: .ID)
        try container.encodeIfPresent(version, forKey: .version)
        try container.encodeIfPresent(createdAt, forKey: .createdAt)
        try container.encodeIfPresent(updatedAt, forKey: .updatedAt)
        try container.encodeIfPresent(spec, forKey: .spec)
        try container.encodeIfPresent(tLSInfo, forKey: .tLSInfo)
        try container.encodeIfPresent(rootRotationInProgress, forKey: .rootRotationInProgress)
        try container.encodeIfPresent(dataPathPort, forKey: .dataPathPort)
        try container.encodeIfPresent(defaultAddrPool, forKey: .defaultAddrPool)
        try container.encodeIfPresent(subnetSize, forKey: .subnetSize)
    }
}

