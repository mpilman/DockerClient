//
// SwarmSpecCAConfigExternalCAsInner.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct SwarmSpecCAConfigExternalCAsInner: Codable, JSONEncodable, Hashable {

    public enum ModelProtocol: String, Codable, CaseIterable {
        case cfssl = "cfssl"
    }
    /** Protocol for communication with the external CA (currently only `cfssl` is supported).  */
    public var _protocol: ModelProtocol? = .cfssl
    /** URL where certificate signing requests should be sent.  */
    public var URL: String?
    /** An object with key/value pairs that are interpreted as protocol-specific options for the external CA driver.  */
    public var options: [String: String]?
    /** The root CA certificate (in PEM format) this external CA uses to issue TLS certificates (assumed to be to the current swarm root CA certificate if not provided).  */
    public var cACert: String?

    public init(_protocol: ModelProtocol? = .cfssl, URL: String? = nil, options: [String: String]? = nil, cACert: String? = nil) {
        self._protocol = _protocol
        self.URL = URL
        self.options = options
        self.cACert = cACert
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case _protocol = "Protocol"
        case URL
        case options = "Options"
        case cACert = "CACert"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(_protocol, forKey: ._protocol)
        try container.encodeIfPresent(URL, forKey: .URL)
        try container.encodeIfPresent(options, forKey: .options)
        try container.encodeIfPresent(cACert, forKey: .cACert)
    }
}

